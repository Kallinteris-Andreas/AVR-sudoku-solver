%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% WARNING: Two pdflatex runs should be done each time, to update correctly LastPage    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt, a4, hidelinks]{article}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english]{babel}

\usepackage{siunitx}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{geometry}

\usepackage{fancyhdr}
\usepackage{lastpage}

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\cfoot{Page \thepage \hspace{1pt} of \pageref{LastPage}}

\usepackage{hyperref}                           
\usepackage{xcolor}                             
\hypersetup{                                     
	%colorlinks,                                    
	%linkcolor={red!50!black},                 
	citecolor={blue!50!black},                  
	urlcolor={blue!80!black}
}                                                
\usepackage{xurl}  

\usepackage{algpseudocode}

%https://tex.stackexchange.com/questions/53357/switch-cases-in-algorithmic
% New definitions
\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicassert{\texttt{assert}}
\algnewcommand\Assert[1]{\State \algorithmicassert(#1)}%
% New "environments"
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}%
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}%
\algtext*{EndSwitch}%
\algtext*{EndCase}%


\begin{document}

\newgeometry{left=1in,right=1in,top=1in,bottom=1in}
\noindent \rule{\textwidth}{3pt}
\begin{center}
	{\bf \Large{Milestone 1 Report - Sudoku on AVR}}\\
	ACE411-Embedded Microprocessor Systems \\
	Winter semester of academic year 2021-2022
	\rule{\textwidth}{0.2mm} 
	\begin{tabular}{l r}
		Kallinteris Andreas:& 2017030066 \\ 
		Lioudakis Emmanouil:      &2018030020 
	\end{tabular} \vrule \hspace{3mm}
	\indent	Team number on eclass:  5
	\rule{\textwidth}{1pt}
\end{center}

\section*{Description of the program}
\subsubsection*{Block diagram of the program (pseudocode)}
The main function constists of a main loop that call the sudoku solving function, if needed:
\begin{center}
\begin{algorithmic}
\Function{main}{} \\
init() \\
\noindent enable global interrupts
\noindent \While{true} 
    \If{ solve\_barrier is true }
		\If{ solved }
        \State solve\_barrier $\gets$ false
\EndIf
\EndIf
\EndWhile
\EndFunction 
\end{algorithmic}
\end{center}

\noindent The interrupt handler to receive data from the serial port:
\begin{center}
\begin{algorithmic}
\Function{USART-ISR}{}
\Switch{ received\_character }
	\Case{A or T or B or S or B or O or K} \\
		\hskip4.0em set the appropriate flag
	\EndCase 
	\Case{C} \\
		\hskip4.0em set the appropriate flag \\
		\hskip4.0em clear(); /* To clear the grid */ 
	\EndCase 
	\Case{N or D} \\
		\hskip4.0em set the appropriate flag \\
		\hskip4.0em prepare the arguments counter
	\EndCase 
	\Case{$<$CR$>$} \\
		\hskip4.0em do nothing
	\EndCase 
	\Case{$<$LF$>$}
		\If{command is AT or C or N}
			send OK
		\ElsIf{command is P}
			set the solving barrier flag
			send OK
		\ElsIf{command is S}
			set the transmit barrier flag
			send the first cell
		\ElsIf{command is T}
			\If{transmit\_barrier is true}
				send the next cell
			\EndIf
		\ElsIf{command is B}
			unset the solving barrier flag
			send OK
		\ElsIf{command is D}
			send the specific cell
		\EndIf
	\EndCase 
	\Case{ number between 1 and 9 }
		\If{command is N}
			store X, Y or VALUE (based on the arguments counter)
		\ElsIf{command is D}
			store X or Y (based on the arguments counter)
		\EndIf
	\EndCase 
\EndSwitch
\EndFunction
\end{algorithmic}
\end{center}		

\noindent The interrupt handler to update the LEDs:
\begin{center}
\begin{algorithmic}
\Function{TIMER1-COMPARE\_MATCH-ISR}{} \\
	\hskip4.0em update PORTA
\EndFunction
\end{algorithmic}
\end{center}	

\noindent The init function:
\begin{center}
\begin{algorithmic}
\Function{init}{} \\
	\hskip4.0em set all the counters to their initial values \\
	\hskip4.0em unset all the flags \\
	\hskip4.0em initialize PORTA \\
	\hskip4.0em initialize TIMER1 \\
	\hskip4.0em initialize the sudoku board \\
	\hskip4.0em initialize the serial port
\EndFunction
\end{algorithmic}
\end{center}	 

\subsubsection*{The sudoku solving algorithm}
*TO BE COMPLETED BY ANDREAS

\subsubsection*{Controlling the LED progress bar}
To update the LEDs that show the progress of solving, there were two options. The first one was updating the PORTA register every time we change the value of a cell and the second one was refreshing the LEDs with a 30Hz frequency. The former option would consume many clock cycles (because on every PORTA update, its new value is read from flash, which needs 3 clock cycles many times each second), when the latter would consume those 3 cycles only 30 times per second, which is pleasant for the human eye. So, the latter was used by enabling Timer/Counter1 and using its Output Compare Match Interrupt. The interrupt is fired with a 30Hz frequency and it simply updates the value of PORTA.

\subsubsection*{USART interfacing}
As the assignment states, the serial port is configured at 9600 baud, 8 data bits, 1 stop bit and no parity.
\subsubsection*{Receiving from the serial port}
When a character is sent to the serial port, the USART\_RXC interrupt is triggered. In the interrupt handler, based on the receiver character, if it is a command character, a flag is set, else if it is a number it is stored in the memory. After receiving the line-feed character, the command is executed. \\
It is important to note that in the case of ''play'' command, the interrupt service routine does not call the solving function, but simply sets the solving flag and returns. This is done to return back as fast as possible, and then start solving with the interrupts enabled (when the ISR is called, the interrupts are disabled until it returns). In that way, while solving a break or a debug command can be received and executed (by interrupting the solving function). If the ISR called the solve function, until completing solving, the interrupts would be disabled, and any new characters from the serial port would not be read.

\subsubsection*{Transmitting to the serial port}
To transmit a character, a polling procedure is used. A loop is done to wait until the UDR register to get empty and then we write the characted to be transmitted. Practically, in this project polling is not actually done. The baud rate is extremely low, so the UDR register will be already empty, every time we want to transmit a character (every 10000 clock cycles approximately).

\section*{Microchip configuration - Compilation process}
Since the code is written using the C++ language (using newer standards than the supported from Microchip Studio), some modifications should be done to the default settings of a new C++ project.  \\
Firstly, add the symbol “AVR” to the compiler’s symbols:\\
\includegraphics[scale=0.75]{CPP_AVR_SYMBOL.png} \\
Secondly, add the flag “-std=c++17” to the compiler’s flags:\\
\includegraphics[scale=0.75]{CPP_STD_17.png}  \\
The optimization level should be set to “-O2 (Optimize more)''.\\
Finally, the SIMULATION\_MODE should be defined (by uncommenting the line 25 of main.cpp). When it is defined, the program will read from TCNT2 instead of UDR and will redi-rect its output from UDR to TCNT0. By doing that, the program can be simulated with the provided stimuli files.


\section*{Resource usage}
After compiling the code, the following resource usage is reported: \\
\includegraphics[width = \textwidth]{RESOURCES.png} 

\subsubsection*{Program memory (flash)}
Except from the code, two arrays (look up tables) are stored in flash: 
\begin{itemize}
\item The led\_bar\_LUT (defined in sudoku.h), which contains the decoding data for the LED progress bar (holds 82 bytes, in addresses 0x018c -- 0x01dd).
\item The div\_9\_LUT (defined in LUT.hpp), which contains pre-calculated value to make the solving proccess faster (holds 162 bytes, in adresses 0x00ea -- 0x018b).
\end{itemize}
The rest bytes (6352-82-162 = 6108) are reserved by the code instructions.

\subsubsection*{Static RAM (SRAM)}
The global variables used to control the serial port are the struct of flags for the received character(11 bits or 2 bytes -- 0x0062-0x0063), the union for the X counters (1 byte - 0x0061), the union for the Y counters (1 byte - 0x0060) and the counter for the arguments (1 byte - 0x00b7). The rest of the 88 bytes are used for the base\_board object (an instance of the sudoku class). Inside this object is stored the 9x9 sudoku grid as a two dimensioned array of unsigned integers. \\
During the solving process, almost the whole remaining memory (1024-88 = 936 bytes) is used to save temporary results. (ANDREAS SHOULD EVALUATE THIS)



\section*{Simulation in Microchip Studio, using stimuli files}
Three stimuli files are submitted with the code (in the folder STIMULI\_FILES):
\begin{itemize}
\item simple\_solve.stim, which feeds the program with one sudoku board (the one shown in the assignment), waits until the sudoku is solved and sends the results back.
\item break\_debug\_test.stim, which feeds the program with the same sudoku board as above, but while solving, a “break” command stops the solving process, and using the “debug” command, the contents of some cells are read.
\item two\_sudokus.stim, which feeds the program with two sudoku boards, one after another. After solving the first and sending back the results, a “clear” command is executed and then the grid is filled with the second sudoku, it is solved and the results are sent back to the serial port.
\end{itemize}
Using the Microchip Studio debugging tools (Run To Cursor and Step Into) and by watching the memory contents (e.g. the values that are completed each moment in the sudoju grid, or if the flag bits are set to true/false), the functionality of the program can be evaluated.

\section*{Testing the code on real hardware (STK500)}
\subsubsection*{Using PuTTY}
Three tests have been done on hardware using PuTTY. The content of the PuTTY terminal is provided in the following files:
\begin{itemize}
\item simple\_solve\_tty.log, which feeds the program with one sudoku board (the one shown in the assignment), waits until the sudoku is solved and sends the results back.
\item break\_debug\_tty.log, which feeds the program with a difficult sudoku board from \url{https://www.websudoku.com/images/example-steps.html} (to slow the solving process and have the time to give manually a break command), but while solving, a “break” command stops the solving process, and using the “debug” command, the contents of some cells are read.
\item two\_sudokus\_tty.log, which feeds the program with two sudoku boards, one after another. After solving the first and sending back the results, a “clear” command is executed and then the grid is filled with the second sudoku, it is solved and the results are sent back to the serial port.
\end{itemize}
On each file, an identifier is placed in the start of each line, to show who sent this command ([PC] or [STK]).\\
Important note: While configuring the serial connection in PuTTY the flow control can be set either to ``None'', or to ``XON/XOFF'' without any problem. Even when using XON/XOFF, the baud rate is so low, so the buffers of the two communicating devices (the PC and the STK) will never overflow.

\subsubsection*{Using the interface program developed by Odysseas Stavrou}
Although the program has still some bugs (reported to Odysseas) and part of the functionality cannot be tested with it (such as the break command), it can show useful statistics for the sudoku solver. It was used to find the solving time of many sudokus. Five random sudokus of each difficulty level were solved, giving the following results:
\begin{center}
\begin{tabular}{ |l|c|c|c|c|c| } 
 \hline
              & Game 1  & Game 2 & Game 3 & Game 4 & Game 5 \\  \hline
 Easy      &  \SI{57}{\micro\second}  &   \SI{33.6}{\micro\second}   & \SI{62.8}{\micro\second}  &\SI{22.4}{\micro\second}     &\SI{84.3}{\micro\second} \\  \hline
 Medium &   \SI{7.2512}{\milli\second}  &   \SI{72.5}{\micro\second}   & \SI{2.4176}{\milli\second}    & \SI{74.2}{\micro\second}  &\SI{81.7}{\micro\second}  \\  \hline
 Hard     &   \SI{8.6831}{\milli\second}    &    \SI{51.1}{\micro\second}  & \SI{16.447}{\milli\second}   & \SI{63.6}{\micro\second}  & \SI{53.9}{\micro\second}    \\  \hline
 Ultra     &  \SI{432.3558}{\milli\second}   &    \SI{2.1232918}{\second}   & \SI{53.7178259}{\second}  & \SI{200.7779}{\milli\second}   & \SI{7.2966281}{\second}    \\  \hline
\end{tabular}
\end{center}


\section*{STK500 configuration}
The STK500 development board we have received has installed the ATmega16L microcontroller, which is fully compatible with the ATmega16 used in Microchip Studio. PORTA is fully functional, and therefore connected to the LEDs. An external crystal of 10MHz is used. Since ISP (In System Programmer) programming mode is used, the following jumpers are mounted:
\begin{description}
\item[VTARGET] mounted, to use the on-boars supply voltage.
\item[AREF] mounted, to use the AVR's AREF as reference volatge for the A/D converter on AVR. Although the A/D converter is not used in this project, the jumper is mounted, because this is the default setting.
\item[RESET] mounted, to be able to use the on-board reset button.
\item[XTAL1] mounted, to use the external crystal.
\item[OSCSEL] mounted to pins 2 and 3 to use the on-board crystal signal as clock signal.
\end{description}


\end{document}