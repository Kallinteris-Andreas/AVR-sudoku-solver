\documentclass[12pt, a4]{article}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[english]{babel}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{geometry}

\usepackage{fancyhdr}
\usepackage{lastpage}

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\cfoot{Page \thepage \hspace{1pt} of \pageref{LastPage}}

\begin{document}

\newgeometry{left=1in,right=1in,top=1in,bottom=1in}
\noindent \rule{\textwidth}{3pt}
\begin{center}
	{\bf \Large{Milestone 1 Report}}\\
	ACE411-Embedded Microprocessor Systems \\
	Winter semester of academic year 2021-2022
	\rule{\textwidth}{0.2mm} 
	\begin{tabular}{l r}
		Kallinteris Andreas:& 2017030066 \\ 
		Lioudakis Emmanouil:      &2018030020 
	\end{tabular} \vrule \hspace{3mm}
	\indent	Team number on eclass:  5
	\rule{\textwidth}{1pt}
\end{center}

\section*{STK500 configuration}
The STK500 development board we have received has installed the ATmega16L microcontroller, which is fully compatible with the ATmega16 used in Microchip Studio. PORTA is fully functional, and therefore connected to the LEDs. An external crystal of 10MHz is used. Since ISP (In System Programmer) programming mode is used, the following jumpers are mounted:
\begin{description}
\item[VTARGET] mounted, to use the on-boars supply voltage.
\item[AREF] mounted, to use the AVR's AREF as reference volatge for the A/D converter on AVR. Although the A/D converter is not used in this project, the jumper is mounted, because this is the default setting.
\item[RESET] mounted, to be able to use the on-board reset button.
\item[XTAL1] mounted, to use the external crystal.
\item[OSCSEL] mounted to pins 2 and 3 to use the on-board crystal signal as clock signal.
\end{description}

\section*{Microchip configuration - Compilation process}
Since the code is written using the C++ language (using newer standards than the supported from Microchip Studio), some modifications should be done to the default settings of a new C++ project.  \\
Firstly, add the symbol “AVR” to the compiler’s symbols:\\
\includegraphics[scale=0.75]{CPP_AVR_SYMBOL.png} \\
Secondly, add the flag “-std=c++17” to the compiler’s flags:\\
\includegraphics[scale=0.75]{CPP_STD_17.png}  \\
The optimization level should be set to “-O2 (Optimize more)''.\\
Finally, the SIMULATION\_MODE should be defined (by uncommenting the line 25 of main.cpp). When it is defined, the program will read from TCNT2 instead of UDR and will redi-rect its output from UDR to TCNT0. By doing that, the program can be simulated with the provided stimuli files.

\section*{Description of the program}

\subsubsection*{Storing the sudoku in memory}
*object, instance on main.cpp

\subsubsection*{The sudoku solving algorithm}
*TO BE COMPLETED BY ANDREAS

\subsubsection*{Controlling the LED progress bar}
To update the LEDs that show the progress of solving, there were two options. The first one was updating the PORTA register every time we change the value of a cell and the second one was refreshing the LEDs with a 30Hz frequency. The former option would consume many clock cycles (because on every PORTA update, its new value is read from flash, which needs 3 clock cycles many times each second), when the latter would consume those 3 cycles only 30 times per second, which is pleasant for the human eye. So, the latter was used by enabling Timer/Counter1 and using its Output Compare Match Interrupt. The interrupt is fired with a 30Hz frequency and it simply updates the value of PORTA.

\subsubsection*{USART interfacing}
As the assignment states, the serial port is configured at 9600 baud, 8 data bits, 1 stop bit and no parity.
\subsubsection*{Receiving from the serial port}
When a character is sent to the serial port, the USART\_RXC interrupt is triggered. In the interrupt handler, based on the receiver character, if it is a command character, a flag is set, else if it is a number it is stored in the memory. After receiving the line-feed character, the command is executed. \\
It is important to note that in the case of ''play'' command, the interrupt service routine does not call the solving function, but simply sets the solving flag and returns. This is done to return back as fast as possible, and then start solving with the interrupts enabled (when the ISR is called, the interrupts are disabled until it returns). In that way, while solving a break or a debug command can be received and executed (by interrupting the solving function). If the ISR called the solve function, until completing solving, the interrupts would be disabled, and any new characters from the serial port would not be read.

\subsubsection*{Transmitting to the serial port}
To transmit a character, a polling procedure is used. A loop is done to wait until the UDR register to get empty and then we write the characted to be transmitted. Practically, in this project polling is not actually done. The baud rate is extremely low, so the UDR register will be already empty, every time we want to transmit a character (every 10000 clock cycles approximately).

\section*{Resource usage}
After compiling the code, the following resource usage is reported: \\
\includegraphics[width = \textwidth]{RESOURCES.png} 

\subsubsection*{Program memory (flash)}
Except from the code, two arrays (look up tables) are stored in flash: 
\begin{itemize}
\item The led\_bar\_LUT (defined in sudoku.h), which contains the decoding data for the LED progress bar (holds 82 bytes, in addresses 0x .. 0x).
\item The div\_9\_LUT (defined in LUT.hpp), which contains the ******** (holds 162 bytes, in adresses 0x .. 0x).
\end{itemize}
The rest bytes (6352-82-162 = 6108) are reserved by the code instructions.

\subsubsection*{Static RAM (SRAM)}


\section*{Simulation in Microchip Studio, using stimuli files}
X stimuli files are submitted with the code:
\begin{itemize}
\item *a, which feeds the program with one sudoku board (the one shown in the assign-ment), waits until the sudoku is solved and sends the results back.
\item *a, which feeds the program with the same sudoku board as above, but while solving, a “break” command stops the solving process, and using the “debug” command, the contents of some cells are read.
\item *a, which feeds the program with two sudoku boards, one after another. After solving the first and sending back the results, a “clear” command is executed and then the grid is filled with the second sudoku, it is solved and the results are sent back to the serial port.
\end{itemize}

\section*{Testing the code on real hardware (STK500)}
\subsubsection*{Using PuTTY}
\subsubsection*{Using the interface program developed by Odysseas Stavrou}


\end{document}